Program to check palindrome numbers.
Program to reverse integer in JAVA.
Program to finding missing numbers in array.
Program to find duplicate numbers in JAVA array.
Program to find the largest & smallest numbers in an array.
Program to swap two two integers without using third variable and two swap strings without using third variable.
Program to find prime numbers.
Program to find Armstrong number.
Program to find factorial of a number.
Program to find duplicate words in a given strings.
Program to print count of vowels in string in java.
Program sorting an array in ascending order by removing duplicates.
Program to check palindrome string.
Program to count digits in a number.
Program to count even odd digit in a number.
Program to count sum of digits in a number.
Program to find largest of 3 numbers.
Program to generate random numbers & strings in java.
Program to find sum of elements in array.
Program to print number of words, character frequency in string.
Program to print characters in descending order of frequency.
Program to find majority elements in an array.
Program to sort names in an array.
Program to find intersection of elements into arrays in java.
Program to check panagram.
Program to find longest substring without repetition.
Program for string compression.
Program to get the first letter of each word string.
Program to print all sub strings for a given strings.
Program for Stack implementation using two array in java.
Program for Stack implementation using array in java.
Program for Binary search in java.
Program to move all zero to end of array.
Program to move all negative number in start of array & +ve number in end of an array.
Program to count number of vowels in a given string.
Program to count the number of words in a given string.
Program to reverse each word in a given string.
Program to find numbers of words characters and number in a given text file.
Program to print pyramid pattern of numbers?
Program to reverse a string without using loops and build-in functions.
Program to generate Fibonacci series.
Program to Print even and odd number in an array.
Program to check the quality of two arrays.
Program for how to reverse the order of elements in arraylist in java?
Program for searching an element in array using a linear search.
Program for searching an element in array using a Binary search.
Program for Sorting an array using bubble sort.
Program to sort elements in an array using build-in methods.
Program to remove junk or special characters in string.
Program to remove white spaces in string.
Program to read data from text file.
Program to write data in text file.
Program to perform calculator operation.
Program to find the second minimum and maximum number in an array.


==========================================================================
 program-
 
1- remove the duplicates in the string without using any inbuilt API (basically without using list or any other collection)
============================================================================

To remove duplicates from a string without using any built-in APIs or collections, you can utilize a simple algorithm that iterates over each character of the string and keeps track of the unique characters encountered so far. Here's an example implementation in Java:


public class RemoveDuplicatesFromString {
    public static void main(String[] args) {
        String input = "Hello World";
        String result = removeDuplicates(input);
        System.out.println(result); // Output: Helo Wrd
    }

    public static String removeDuplicates(String str) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (isUnique(sb.toString(), c)) {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    public static boolean isUnique(String str, char c) {
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == c) {
                return false;
            }
        }
        return true;
    }
}
In the removeDuplicates method, we iterate over each character of the input string. For each character, we check if it is unique by calling the isUnique method. This method iterates over the characters accumulated so far (stored in the StringBuilder), comparing each character with the current character. If a match is found, we return false to indicate that the character is not unique. Otherwise, we append the character to the StringBuilder.

Finally, we convert the StringBuilder back to a string and return the result.

Note that this approach has a time complexity of O(n^2) due to the nested loop in the isUnique method, where n is the length of the input string. If you have very long strings, this approach may not be efficient. In such cases, utilizing collections or other built-in APIs would be more suitable.
==============================
most efficient way
==============================
To remove duplicates from a string efficiently without using any built-in APIs or collections, you can utilize a HashSet to keep track of the unique characters encountered so far. Here's an example implementation in Java:


public class RemoveDuplicatesFromString {
    public static void main(String[] args) {
        String input = "Hello World";
        String result = removeDuplicates(input);
        System.out.println(result); // Output: Helo Wrd
    }

    public static String removeDuplicates(String str) {
        StringBuilder sb = new StringBuilder();
        HashSet<Character> seen = new HashSet<>();

        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (!seen.contains(c)) {
                seen.add(c);
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
In this implementation, we use a HashSet<Character> called seen to keep track of the unique characters encountered so far. We iterate over each character of the input string, and for each character, we check if it is already present in the seen set using the contains method. If it is not present, we add it to the set and append it to the StringBuilder.

This approach has a time complexity of O(n), where n is the length of the input string. The contains operation in a HashSet has an average time complexity of O(1), which makes the overall process more efficient compared to the previous approach.

Note that this implementation assumes case-sensitive comparison. If you want to consider case-insensitive comparison, you can convert the characters to lowercase or uppercase before checking if they are present in the seen set.



===================================================================================
2- password validation (for eg a string contains a special char, 2 alphabets, 2 numeric digit and lenght should be of 10 characters)
===================================================================================
To validate a password with the following requirements:

Contains at least one special character
Contains at least two alphabets
Contains at least two numeric digits
Has a length of 10 characters
You can use regular expressions in Java to perform the validation. Here's an example implementation:

import java.util.regex.Pattern;

public class PasswordValidator {
    public static void main(String[] args) {
        String password = "P@ssw0rd12";
        boolean isValid = validatePassword(password);
        System.out.println(isValid); // Output: true
    }

    public static boolean validatePassword(String password) {
        String pattern = "^(?=.*[!@#$%^&*()])(?=.*[a-zA-Z].*[a-zA-Z])(?=.*[0-9].*[0-9]).{10}$";
        return Pattern.matches(pattern, password);
    }
}
In this implementation, the validatePassword method takes a password string as input and checks it against the specified regular expression pattern.

The pattern ^(?=.*[!@#$%^&*()])(?=.*[a-zA-Z].*[a-zA-Z])(?=.*[0-9].*[0-9]).{10}$ consists of the following parts:

(?=.*[!@#$%^&*()]): Positive lookahead to check if the password contains at least one special character from the specified set.
(?=.*[a-zA-Z].*[a-zA-Z]): Positive lookahead to check if the password contains at least two alphabets.
(?=.*[0-9].*[0-9]): Positive lookahead to check if the password contains at least two numeric digits.
.{10}: Specifies that the password should have a length of exactly 10 characters.
If the password matches the specified pattern, the Pattern.matches method will return true, indicating that the password is valid. Otherwise, it will return false.

You can modify the regular expression pattern based on your specific requirements for password validation.



==================================
3- write the code to read the value from excel sheet
==================================
To read values from an Excel sheet in Java, you can use a library like Apache POI. Here's an example code snippet that demonstrates how to read values from an Excel sheet using Apache POI:

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.FileInputStream;
import java.io.IOException;

public class ExcelReader {
    public static void main(String[] args) {
        String filePath = "path_to_your_excel_file.xlsx";
        String sheetName = "Sheet1";

        try (FileInputStream fis = new FileInputStream(filePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheet(sheetName);
            if (sheet != null) {
                int rowCount = sheet.getLastRowNum();
                for (int i = 0; i <= rowCount; i++) {
                    Row row = sheet.getRow(i);
                    if (row != null) {
                        int columnCount = row.getLastCellNum();
                        for (int j = 0; j < columnCount; j++) {
                            Cell cell = row.getCell(j);
                            if (cell != null) {
                                String cellValue = getCellValueAsString(cell);
                                System.out.println(cellValue);
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String getCellValueAsString(Cell cell) {
        if (cell.getCellType() == CellType.STRING) {
            return cell.getStringCellValue();
        } else if (cell.getCellType() == CellType.NUMERIC) {
            return String.valueOf(cell.getNumericCellValue());
        } else if (cell.getCellType() == CellType.BOOLEAN) {
            return String.valueOf(cell.getBooleanCellValue());
        } else {
            return "";
        }
    }
}
In this code snippet, you need to provide the filePath variable with the path to your Excel file and specify the sheetName variable with the name of the sheet you want to read from.

The code uses the Apache POI library to open the Excel file, access the specified sheet, and iterate over the rows and cells. For each cell, it calls the getCellValueAsString method to retrieve the cell value as a string.

Make sure to include the Apache POI dependencies in your project's build file or dependency management tool. For example, if you're using Maven, you can include the following dependencies in your pom.xml file:

<dependencies>
    <!-- Apache POI -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi</artifactId>
        <version>5.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
        <version>5.0.0</version>
    </dependency>
</dependencies>
Remember to replace path_to_your_excel_file.xlsx with the actual path to your Excel file.



=========================================
4- write the code find the Longest palindrome in given string
 Input = "babad"
 output = "bab"
 note "aba" is also a valid answer
=========================================

To find the longest palindrome in a given string, you can use the following code:


public class LongestPalindrome {
    public static void main(String[] args) {
        String input = "babad";
        String longestPalindrome = findLongestPalindrome(input);
        System.out.println(longestPalindrome);  // Output: bab
    }

    public static String findLongestPalindrome(String input) {
        if (input == null || input.length() < 2) {
            return input;
        }

        String longestPalindrome = "";

        for (int i = 0; i < input.length(); i++) {
            String oddPalindrome = expandAroundCenter(input, i, i);
            String evenPalindrome = expandAroundCenter(input, i, i + 1);

            String currentLongest = oddPalindrome.length() > evenPalindrome.length() ? oddPalindrome : evenPalindrome;

            if (currentLongest.length() > longestPalindrome.length()) {
                longestPalindrome = currentLongest;
            }
        }

        return longestPalindrome;
    }

    private static String expandAroundCenter(String input, int left, int right) {
        while (left >= 0 && right < input.length() && input.charAt(left) == input.charAt(right)) {
            left--;
            right++;
        }

        return input.substring(left + 1, right);
    }
}
In this code, the findLongestPalindrome method takes the input string and iterates over each character. For each character, it expands around the center to find the longest palindromic substring.

The expandAroundCenter method performs the expansion by comparing characters from the center towards both ends of the string. It stops expanding when the characters are no longer equal or when the indices go out of bounds.

The main logic is to compare the length of odd-length palindromes (centered at a single character) and even-length palindromes (centered between two characters) at each position. The longest palindrome found so far is stored in the longestPalindrome variable.

Finally, the method returns the longest palindrome found in the given input string.

Note that the code assumes the input string is case-sensitive. If you want to ignore case, you can convert the input string to lowercase or uppercase before performing the palindrome check.



===============================================================
5- 
str1 = Maersk Global Service Center Maersk Center Global Service Global Service Global Maesrk
O/p = Maersk =3, Global=4, Service=3, Center=2
==============================================================

To count the occurrences of each word in a given string, you can use the following code:

java
Copy code
import java.util.HashMap;
import java.util.Map;

public class WordCount {
    public static void main(String[] args) {
        String str1 = "Maersk Global Service Center Maersk Center Global Service Global Service Global Maesrk";
        Map<String, Integer> wordCountMap = countWords(str1);
        printWordCounts(wordCountMap);
    }

    public static Map<String, Integer> countWords(String input) {
        String[] words = input.split(" ");
        Map<String, Integer> wordCountMap = new HashMap<>();

        for (String word : words) {
            wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1);
        }

        return wordCountMap;
    }

    public static void printWordCounts(Map<String, Integer> wordCountMap) {
        for (Map.Entry<String, Integer> entry : wordCountMap.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
}
In this code, the countWords method takes the input string and splits it into individual words using the space delimiter. It then counts the occurrences of each word using a HashMap called wordCountMap. The put method is used to add the word to the map with its count. If the word already exists in the map, its count is incremented by 1 using getOrDefault.

The printWordCounts method is used to iterate over the wordCountMap and print the word along with its count.

When you run the code, it will output the word counts as follows:

makefile
Copy code
Maersk = 3
Center = 2
Global = 4
Service = 3
Maesrk = 1
Note that the code treats words as case-sensitive. If you want to ignore case and consider "Maersk" and "maersk" as the same word, you can convert the input string and each word to lowercase or uppercase before counting.



========================
str1 = Maersk Global Service Center
str2= esr
o/p = Mak Global vice Cnt
========================
To remove all occurrences of characters in a given string from another string, you can use the following code:


public class RemoveCharacters {
    public static void main(String[] args) {
        String str1 = "Maersk Global Service Center";
        String str2 = "esr";
        String result = removeCharacters(str1, str2);
        System.out.println(result);  // Output: Mak Global vice Cnt
    }

    public static String removeCharacters(String input, String charactersToRemove) {
        StringBuilder sb = new StringBuilder();

        for (char ch : input.toCharArray()) {
            if (charactersToRemove.indexOf(ch) == -1) {
                sb.append(ch);
            }
        }

        return sb.toString();
    }
}
In this code, the removeCharacters method takes two strings: input (the original string) and charactersToRemove (the string containing characters to be removed). It uses a StringBuilder to build the resulting string.

The method iterates over each character in the input string. It checks if the character exists in the charactersToRemove string using the indexOf method. If the character is not found (i.e., indexOf returns -1), it is appended to the StringBuilder.

Finally, the method returns the resulting string after removing all occurrences of the characters specified in charactersToRemove.

When you run the code with the given inputs, it will output:


Mak Global vice Cnt
The characters 'e', 's', and 'r' from the str2 are removed from the str1 to produce the result.



=========================
o/p = Maersk labolG Service retneC
=========================

To reverse the order of words in a string while keeping each word intact, you can use the following code:


public class ReverseWords {
    public static void main(String[] args) {
        String str1 = "Maersk Global Service Center";
        String result = reverseWords(str1);
        System.out.println(result);  // Output: Maersk labolG Service retneC
    }

    public static String reverseWords(String input) {
        String[] words = input.split(" ");
        StringBuilder sb = new StringBuilder();

        for (int i = words.length - 1; i >= 0; i--) {
            sb.append(reverseWord(words[i]));
            if (i > 0) {
                sb.append(" ");
            }
        }

        return sb.toString();
    }

    public static String reverseWord(String word) {
        StringBuilder reversedWord = new StringBuilder(word);
        return reversedWord.reverse().toString();
    }
}
In this code, the reverseWords method takes the input string and splits it into individual words using the space delimiter. It uses a StringBuilder called sb to build the resulting string.

The method then iterates over the words array in reverse order. For each word, it calls the reverseWord method to reverse the characters in the word using a StringBuilder.

Finally, the method returns the resulting string after reversing the order of words while keeping each word intact.

The reverseWord method takes a word and creates a StringBuilder with the word. It then calls the reverse method on the StringBuilder to reverse the characters in the word. The reversed word is converted to a string using toString.

When you run the code with the given input, it will output:

Copy code
Maersk labolG Service retneC
The words in the original string are reversed individually while keeping each word intact.


=======================================
3-palindrome program if the number is palindrome or not.
=======================================

public class PalindromeNumber {
    public static void main(String[] args) {
        int number = 12321; // Number to check for palindrome

        if (isPalindrome(number)) {
            System.out.println(number + " is a palindrome.");
        } else {
            System.out.println(number + " is not a palindrome.");
        }
    }

    public static boolean isPalindrome(int number) {
        int originalNumber = number;
        int reverse = 0;

        while (number != 0) {
            int remainder = number % 10;
            reverse = reverse * 10 + remainder;
            number /= 10;
        }

        return originalNumber == reverse;
    }
}
In this code, we have a isPalindrome method that takes an integer number as input and returns true if the number is a palindrome, and false otherwise.

Inside the isPalindrome method, we create a copy of the original number (originalNumber) and initialize a reverse variable to 0. We then use a while loop to reverse the number by extracting the last digit (remainder) using the modulo operator % and adding it to the reverse variable. We keep dividing the number by 10 to remove the last digit in each iteration. Finally, we compare the originalNumber with the reversed number (reverse) and return true if they are equal, indicating that the number is a palindrome.

In the main method, we call the isPalindrome method with a sample number (12321 in this case) and print the appropriate message based on the returned value.

The output of the above code will be:

csharp
Copy code
12321 is a palindrome.
This indicates that the number 12321 is a palindro


=============
4- FibonacciSeries
==============

public class FibonacciSeries {
    public static void main(String[] args) {
        int terms = 10; // Number of terms in the Fibonacci series to be printed

        System.out.println("Fibonacci Series:");

        // Print the first two terms of the series
        int firstTerm = 0;
        int secondTerm = 1;
        System.out.print(firstTerm + " " + secondTerm);

        // Calculate and print the remaining terms of the series
        for (int i = 3; i <= terms; i++) {
            int nextTerm = firstTerm + secondTerm;
            System.out.print(" " + nextTerm);

            // Update the values of firstTerm and secondTerm for the next iteration
            firstTerm = secondTerm;
            secondTerm = nextTerm;
        }
    }
}
In this code, we initialize the terms variable to the number of terms in the Fibonacci series that we want to print. We then use a for loop to calculate and print each term of the series.

We start by printing the first two terms (firstTerm and secondTerm) outside the loop. Inside the loop, we calculate the next term (nextTerm) by adding the previous two terms (firstTerm and secondTerm). We then print the nextTerm and update the values of firstTerm and secondTerm for the next iteration.

The output of the above code, with terms set to 10, will be:

mathematica
Copy code
Fibonacci Series:
0 1 1 2 3 5 8 13 21 34
This represents the Fibonacci series with the first 10 terms.


========================
5- reverse the string on its own place
========================

To reverse the individual words in a given string while keeping the words in their original order, you can split the string into words, reverse each word, and then join them back together. Here's an example code snippet in Java:


public class ReverseWords {
    public static void main(String[] args) {
        String input = "Hello world";

        String reversed = reverseWords(input);

        System.out.println("Original string: " + input);
        System.out.println("Reversed string: " + reversed);
    }

    public static String reverseWords(String input) {
        String[] words = input.split(" ");
        StringBuilder reversed = new StringBuilder();

        for (String word : words) {
            StringBuilder wordBuilder = new StringBuilder(word);
            wordBuilder.reverse();
            reversed.append(wordBuilder).append(" ");
        }

        return reversed.toString().trim();
    }
}
In this code, we have the reverseWords method that takes a string input as input and reverses the individual words while maintaining the original order.

Inside the reverseWords method, we split the input string into an array of words using the space delimiter. Then, for each word, we create a StringBuilder and reverse it using the reverse method. We append the reversed word followed by a space to the reversed StringBuilder object.

Finally, we convert the reversed StringBuilder to a string using the toString method and remove any trailing spaces using the trim method.

In the main method, we initialize a sample input string "Hello world" and call the reverseWords method to reverse the individual words. We then print both the original and reversed strings.

The output of the above code will be:

c
Copy code
Original string: Hello world
Reversed string: olleH dlrow
This indicates that the individual words in the given string "Hello world" have been successfully reversed while maintaining their original order, resulting in "olleH dlrow".



====================
5- reverse the string
====================


java
Copy code
public class ReverseString {
    public static void main(String[] args) {
        String str = "Hello World";

        String reversed = reverseString(str);

        System.out.println("Original string: " + str);
        System.out.println("Reversed string: " + reversed);
    }

    public static String reverseString(String str) {
        StringBuilder sb = new StringBuilder(str);
        sb.reverse();
        return sb.toString();
    }
}
In this code, we have a reverseString method that takes a string str as input and returns the reversed string.

Inside the reverseString method, we use a StringBuilder to create a mutable string object from the input string. We then call the reverse method on the StringBuilder object to reverse the characters in-place.

Finally, we convert the StringBuilder to a string using the toString method and return the reversed string.

In the main method, we initialize a sample string "Hello World" and call the reverseString method. We then print the original string and the reversed string.

The output of the above code will be:

c
Copy code
Original string: Hello World
Reversed string: dlroW olleH
This indicates that the given string "Hello World" has been successfully reversed to "dlroW olleH".



===========================
5- RemoveDuplicateChar  - from strings
===========================

public class RemoveDuplicateChar {
    public static void main(String[] args) {
        String str = "Hello World";

        String result = removeDuplicates(str);

        System.out.println("Original string: " + str);
        System.out.println("String after removing duplicates: " + result);
    }

    public static String removeDuplicates(String str) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);

            if (sb.indexOf(String.valueOf(ch)) == -1) {
                sb.append(ch);
            }
        }

        return sb.toString();
    }
}
In this code, we have a removeDuplicates method that takes a string str as input and returns a new string with duplicate characters removed.

Inside the removeDuplicates method, we use a StringBuilder to build the resulting string. We iterate through each character in the input string using a for loop. For each character, we check if it already exists in the StringBuilder by using the indexOf method. If the character is not found (i.e., its index is -1), we append it to the StringBuilder.

Finally, we convert the StringBuilder to a string using the toString method and return the result.

In the main method, we initialize a sample string "Hello World" and call the removeDuplicates method. We then print the original string and the string after removing duplicates.

The output of the above code will be:

vbnet
Copy code
Original string: Hello World
String after removing duplicates: Helo Wrd
This indicates that the duplicate characters 'l' and 'o' have been removed from the original string.


==============================
6- CountDuplicateWords - in a given sentence
==============================

To count the occurrence of duplicate words in a given sentence, you can use a combination of a HashMap and String operations. Here's an example code snippet to achieve this:

java
Copy code
import java.util.HashMap;

public class CountDuplicateWords {
    public static void main(String[] args) {
        String sentence = "the quick brown fox jumps over the lazy dog";

        // Split the sentence into individual words
        String[] words = sentence.toLowerCase().split(" ");

        // Create a HashMap to store word frequencies
        HashMap<String, Integer> wordCountMap = new HashMap<>();

        // Iterate through each word
        for (String word : words) {
            // Check if the word exists in the HashMap
            if (wordCountMap.containsKey(word)) {
                // If the word already exists, increment its count
                wordCountMap.put(word, wordCountMap.get(word) + 1);
            } else {
                // If the word is encountered for the first time, add it to the HashMap with count as 1
                wordCountMap.put(word, 1);
            }
        }

        // Print the duplicate words along with their counts
        for (String word : wordCountMap.keySet()) {
            int count = wordCountMap.get(word);
            if (count > 1) {
                System.out.println("Word: " + word + ", Count: " + count);
            }
        }
    }
}
In this code, we first split the input sentence into individual words using the split() method. We convert all the words to lowercase to ensure case-insensitive comparison.

Then, we create a HashMap called wordCountMap to store the word frequencies. We iterate through each word in the words array and check if it exists in the HashMap. If it does, we increment its count by 1. If it doesn't, we add it to the HashMap with an initial count of 1.

Finally, we iterate through the wordCountMap and print the words that have a count greater than 1, which indicates the duplicate words in the sentence.

For the given input sentence "the quick brown fox jumps over the lazy dog", the output will be:

mathematica
Copy code
Word: the, Count: 2
Since the word "the" appears twice in the sentence.



=================
7- SplitStringAndReverse
=================

public class ReverseWords {
    public static void main(String[] args) {
        String input = "Hello World Java";
        String[] words = input.split(" ");

        StringBuilder reversedString = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            reversedString.append(words[i]).append(" ");
        }

        System.out.println(reversedString.toString().trim());
    }
}

In this updated code, we create a StringBuilder named reversedString to build the reversed string. Inside the loop, we append each word from the words array to the reversedString, followed by a space.

Finally, we use reversedString.toString().trim() to convert the StringBuilder object to a string and remove any leading or trailing spaces. Then, we print the reversed string using System.out.println().

================================
8- SecondHighestElement  - in an unsorted array
================================

=============================
9- ReturnIndexOfSubarrayEquallingTarget
=============================

====================
10- Print0To100WithoutLoop
====================

package Pragramming;

public class PrintNumbers {
    public static void main(String[] args)
    {
        printNumber(0);

    }
    private static void printNumber(int num) {
        System.out.println(num);
        if(num<100) {
            printNumber(num+1);
        }
    }
}
In this example, the printNumbers method recursively calls itself, printing the current number and then incrementing it until the number reaches 100. The base case is when the number is equal to 100, in which case the recursion stops.

   
=============
   LongestPalindrome
=============
   public class LongestPalindromeFinder {
    public static String findLongestPalindrome(String str) {
        if (str == null || str.length() == 0) {
            return "";
        }

        String longestPalindrome = "";
        int maxLength = 0;

        for (int i = 0; i < str.length(); i++) {
            // Find palindromes with odd length
            String oddPalindrome = expandAroundCenter(str, i, i);
            if (oddPalindrome.length() > maxLength) {
                maxLength = oddPalindrome.length();
                longestPalindrome = oddPalindrome;
            }

            // Find palindromes with even length
            String evenPalindrome = expandAroundCenter(str, i, i + 1);
            if (evenPalindrome.length() > maxLength) {
                maxLength = evenPalindrome.length();
                longestPalindrome = evenPalindrome;
            }
        }

        return longestPalindrome;
    }

    private static String expandAroundCenter(String str, int left, int right) {
        while (left >= 0 && right < str.length() && str.charAt(left) == str.charAt(right)) {
            left--;
            right++;
        }
        return str.substring(left + 1, right);
    }

    public static void main(String[] args) {
        String input = "babad";
        String longestPalindrome = findLongestPalindrome(input);
        System.out.println("Longest Palindrome: " + longestPalindrome);
    }
}

1- print the array in ascending order
3- code to reverse the string and count the numbers in string
4- Reverse the string preserving the space 
5- Reverse the string without using any inbuilt method

