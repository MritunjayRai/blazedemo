==========================
1- What is out of memory error in java
==========================

An "Out of Memory Error" in Java refers to an error condition that occurs when the Java Virtual Machine (JVM) runs out of available memory to allocate new objects or fulfill memory allocation requests. When the JVM cannot allocate more memory to fulfill a request, it throws an OutOfMemoryError.

There are several types of OutOfMemoryError that can occur in Java, including:

java.lang.OutOfMemoryError: Java heap space: This error occurs when the JVM's heap memory, which is used for dynamic memory allocation of objects, is exhausted. It indicates that the application is creating and retaining too many objects, causing the heap to fill up.

java.lang.OutOfMemoryError: PermGen space (prior to Java 8) or java.lang.OutOfMemoryError: Metaspace (Java 8 onwards): These errors occur when the JVM's permanent generation (PermGen) or metaspace, which is used to store class metadata and interned strings, respectively, is full. It usually indicates that the application is loading too many classes or creating too many interned strings.

java.lang.OutOfMemoryError: Unable to create new native thread: This error occurs when the JVM cannot create any more native threads due to reaching the maximum limit set by the operating system. It indicates that the application is creating threads at a rate that exceeds the system's capacity to handle them.

java.lang.OutOfMemoryError: Requested array size exceeds VM limit: This error occurs when the JVM is unable to allocate an array of the requested size due to exceeding the VM's limit. It usually happens when an application attempts to allocate a very large array.

These errors typically indicate issues with the application's memory usage, such as inefficient memory management, excessive object creation, or inadequate memory configuration. To resolve an OutOfMemoryError, you may need to analyze and optimize your application's memory usage, adjust JVM memory settings, or refactor the code to improve memory efficiency.


===================================
2- What will happen if we make constructor as final
===================================

In Java, the final keyword can be applied to classes, methods, and variables. However, it cannot be applied to constructors.

The purpose of marking a class, method, or variable as final is to indicate that it cannot be subclassed or overridden (in the case of methods) or reassigned (in the case of variables). This provides a level of immutability or restriction on the entity.

Constructors, on the other hand, cannot be overridden or subclassed by default. They are special methods used to initialize objects of a class. Even if you don't explicitly declare a constructor, Java provides a default constructor. So, there is no need to mark constructors as final because they are implicitly final and cannot be overridden or inherited.

If you attempt to mark a constructor as final, it will result in a compilation error. The Java compiler will report that the modifier final is not allowed for constructors.

In summary, you cannot make constructors final in Java because they are already implicitly final by default.


=========================================================
3- what are the different mvn command and gradle command which you have worked
=========================================================

Maven Commands:

mvn clean: Cleans the build artifacts and target directories.
mvn compile: Compiles the source code of the project.
mvn test: Runs the unit tests of the project.
mvn package: Packages the compiled code into an executable JAR, WAR, or other formats.
mvn install: Installs the packaged artifact into the local repository for use as a dependency in other projects.
mvn deploy: Deploys the packaged artifact to a remote repository, such as Nexus or Artifactory.
mvn clean install: Performs a clean build and installs the artifact.
mvn clean test: Cleans the project, compiles the code, and runs the tests.

Gradle Commands:

gradle clean: Cleans the build artifacts and directories.
gradle build: Builds the project, including compilation and running tests.
gradle test: Runs the unit tests of the project.
gradle assemble: Assembles the project without running the tests.
gradle install: Installs the project into the local repository.
gradle publish: Publishes the project to a remote repository.
gradle clean build: Cleans the project and performs a build.
gradle clean test: Cleans the project, builds the code, and runs the tests.
These commands are just a few examples of what can be done with Maven and Gradle. Both build tools offer a wide range of features and customization options to manage dependencies, build configurations, plugins, and more. It's recommended to consult the respective documentation for Maven and Gradle to explore the full set of available commands and their functionalities.



===================================
4- difference between thread.start() and thread.run()
===================================

The start() and run() methods are related to multithreading in Java. Here's the difference between them:

start() Method:

When you invoke the start() method on a Thread object, it creates a new thread of execution and allows that thread to run concurrently with the calling thread.
The start() method takes care of thread initialization, context switching, and invokes the run() method of the thread in a separate thread of execution.
The start() method is asynchronous. It returns immediately after starting the new thread, allowing the calling thread to continue its execution independently.
run() Method:

The run() method represents the actual task or code that needs to be executed by the thread.
When you directly invoke the run() method on a Thread object, it executes the code in the same thread as the caller. It does not create a new thread of execution.
The run() method is synchronous. It will run in the same thread, blocking further execution until the method completes.
In summary, calling start() on a Thread object creates a new thread and invokes the run() method in that new thread, allowing for concurrent execution. On the other hand, invoking run() directly executes the code in the same thread as the caller, without creating a new thread. Therefore, if you want to take advantage of multithreading and run code concurrently, you should use start(). If you simply want to execute the code sequentially without concurrent execution, you can call run().



=======================================================================
5- how to call both the constructor(parameterized and no-arg constructor) using single instance of the class
=======================================================================
In Java, you can call both the parameterized and no-arg constructors of a class using a single instance by using method chaining or constructor chaining.

Here's an example to illustrate how to achieve this:

public class MyClass {
    private String name;
    private int age;
    
    public MyClass() {
        // No-arg constructor
    }
    
    public MyClass(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Getter and Setter methods for name and age
    
    public MyClass initialize(String name, int age) {
        this.name = name;
        this.age = age;
        return this;
    }
    
    public static void main(String[] args) {
        MyClass obj = new MyClass().initialize("John", 25);
        
        // Alternatively, you can also use constructor chaining
        // MyClass obj = new MyClass("John", 25);
        
        // Use the initialized object
        System.out.println("Name: " + obj.getName());
        System.out.println("Age: " + obj.getAge());
    }
}
In the above example, the class MyClass has both a no-arg constructor and a parameterized constructor. To call both constructors using a single instance, we have introduced an initialize() method that sets the values of name and age and returns the instance of the class. This allows us to chain the method call after creating the instance using the no-arg constructor.

Alternatively, you can also achieve constructor chaining by directly calling the parameterized constructor when creating the instance, as shown in the commented line in the main() method.

By using method chaining or constructor chaining, you can initialize the object with the desired values without creating a separate instance for each constructor call.


===============================
6- Difference between List and Set interface
===============================
The List and Set interfaces in Java are both used to store collections of elements, but they have some key differences:

Ordering: List maintains the order of elements as they are inserted and allows duplicate elements. Set, on the other hand, does not guarantee any specific order and does not allow duplicate elements.

Duplicate Elements: List allows duplicate elements, which means you can have multiple occurrences of the same element in a List. Set, on the other hand, does not allow duplicate elements. If you attempt to add a duplicate element to a Set, it will simply ignore the duplicate and not add it.

Index-based Access: List provides index-based access to elements, meaning you can access elements by their position in the list using the get() method. Set does not provide index-based access since it does not maintain any specific order of elements.

Performance: List implementations like ArrayList provide fast access to elements by index, but searching for elements or checking for existence can be slower compared to Set implementations like HashSet or TreeSet. Sets are optimized for fast membership checks using hashing or sorting algorithms.

Iteration: List maintains the insertion order, so iterating over elements in a List will follow the same order in which they were inserted. Set does not guarantee any specific order of iteration, although certain implementations like LinkedHashSet or TreeSet may provide a predictable iteration order.

In summary, List is suitable when you need to maintain an ordered collection that allows duplicate elements and provides index-based access. Set is suitable when you need to store a collection of unique elements without any specific order and need fast membership checks.


===============================================
7- Difference between all the classes which implements List interface
===============================================

The List interface in Java is implemented by several classes, each with its own characteristics and use cases. Here are some commonly used classes that implement the List interface and their key differences:

ArrayList: It is an implementation of the List interface that uses a dynamically resizable array to store elements. It provides fast random access and is efficient when it comes to accessing elements by index. However, adding or removing elements in the middle of the list can be slower compared to LinkedList.

LinkedList: It is another implementation of the List interface that uses a doubly-linked list to store elements. It provides efficient insertion and removal of elements at the beginning or end of the list. However, accessing elements by index is slower compared to ArrayList.

Vector: It is a synchronized implementation of the List interface, which means it is thread-safe. It is similar to ArrayList in terms of functionality but provides additional synchronization, making it suitable for multi-threaded environments. However, due to the synchronization overhead, it can be slower compared to ArrayList.

Stack: It is a subclass of Vector and implements the LIFO (Last-In-First-Out) data structure. It provides methods like push() and pop() to add and remove elements from the top of the stack, respectively. It is commonly used for stack-based operations.


==============================================
8- Difference between all the classes which implements Set interface
===============================================

The Set interface in Java is implemented by several classes, each with its own characteristics and use cases. Here are some commonly used classes that implement the Set interface and their key differences:

HashSet: It is an implementation of the Set interface that uses a hash table to store elements. It provides constant-time performance for the basic operations like add(), remove(), and contains(). However, it does not guarantee any specific order of iteration.

LinkedHashSet: It is a subclass of HashSet that maintains the insertion order of elements. It uses a hash table along with a linked list to keep track of the order of insertion. This makes it slightly slower than HashSet but provides predictable iteration order.

TreeSet: It is an implementation of the Set interface that stores elements in a sorted tree structure. It maintains the elements in sorted order, which makes it suitable for scenarios where you need to access the elements in a sorted manner. However, the operations like add(), remove(), and contains() are slower compared to HashSet and LinkedHashSet.

EnumSet: It is a specialized implementation of the Set interface specifically designed to work with enum types. It provides efficient storage and retrieval of enum values.

ConcurrentSkipListSet: It is a concurrent implementation of the Set interface that provides thread-safe operations. It is based on a skip list data structure, which allows for efficient concurrent access and modification of elements.

These are some of the commonly used classes that implement the Set interface in Java. Each class has its own advantages and trade-offs, so the choice depends on the specific requirements of your application, such as performance, iteration order, or thread-safety.


=========================================   
9- Few scenarios based question from collection Framework
=========================================

Scenario: You have a list of numbers and you want to find the maximum and minimum values from that list. How would you approach this using the Collection Framework?
Answer: You can use the Collections.max() and Collections.min() methods to find the maximum and minimum values from a collection. First, convert your list of numbers to a collection using Arrays.asList() and then use the Collections.max() and Collections.min() methods to get the maximum and minimum values, respectively.

//create a list of the numbers
List<Integer> numbers = Arrays.aslist(5,2,39,11,38);
//find the maximum value
Integer max = Collections.max(numbers);
System.out.println("Maximum value: "+ max);
//find the minimum value
Integer min = Collections.min(numbers);
System.out.println("Minimum value: "+ min);

Scenario: You have a list of strings and you want to sort them in ascending order. How would you accomplish this using the Collection Framework?
Answer: You can use the Collections.sort() method to sort a list of strings in ascending order. Simply pass your list as the argument to the Collections.sort() method, and it will be sorted in-place.

Scenario: You have a map that contains student names as keys and their corresponding scores as values. You want to find the student with the highest score. How would you achieve this using the Collection Framework?
Answer: You can use the Collections.max() method with a custom Comparator to find the entry with the highest score in a map. First, convert the map's entrySet() to a list, and then use the Collections.max() method with a custom Comparator that compares the values of the entries. This will give you the entry with the highest score.

Scenario: You have a set of numbers and you want to remove duplicates from it. How would you do this using the Collection Framework?
Answer: You can use a HashSet to remove duplicates from a set of numbers. Simply create a new HashSet and pass your set of numbers as the constructor argument. The HashSet will automatically remove duplicates, leaving you with a set of unique numbers.

Scenario: You have a list of objects and you want to find the object with a specific property value. How would you accomplish this using the Collection Framework?
Answer: You can use the Stream API along with the filter() method to find objects in a list based on a specific property value. First, convert your list to a stream using stream(), and then use the filter() method with a lambda expression to specify the condition for the property value. Finally, use the findFirst() or findAny() method to retrieve the first matching object.

These are just a few examples of scenarios that can be solved using the Java Collection Framework. The Collection Framework provides a rich set of classes and methods for working with collections, making it a powerful tool for managing and manipulating data.


===============================================
10- Difference between all the classes which implement map interface
===============================================

The Map interface in Java represents a collection of key-value pairs. Here are the differences between some of the commonly used classes that implement the Map interface:

HashMap:

HashMap is an implementation of the Map interface that stores key-value pairs in a hash table.
It allows null values and null keys.
It does not guarantee any specific order of the elements.
It provides constant-time performance for the basic operations (get and put) on average, assuming a good hash function.
TreeMap:

TreeMap is an implementation of the Map interface that stores key-value pairs in a sorted tree structure.
It maintains the elements in sorted order based on the natural ordering of the keys or a custom comparator.
It does not allow null keys but allows null values.
It provides guaranteed logarithmic time complexity for basic operations (get and put).
LinkedHashMap:

LinkedHashMap is an implementation of the Map interface that maintains the insertion order of the elements.
It stores key-value pairs in a hash table with a linked list running through it.
It allows null values and null keys.
It provides a predictable iteration order that is either insertion order or the order defined by the access order (using the accessOrder parameter in the constructor).
ConcurrentHashMap:

ConcurrentHashMap is an implementation of the Map interface that allows concurrent access by multiple threads without the need for external synchronization.
It is designed to provide high concurrency and scalability.
It allows concurrent read operations and concurrent write operations on different segments of the map.
It does not allow null keys or values.
Hashtable:

Hashtable is an implementation of the Map interface that is synchronized (thread-safe).
It provides similar functionality to HashMap but with the additional synchronization overhead.
It does not allow null keys or values.
It provides legacy methods that are not part of the Map interface, such as contains() and containsKey().
These are just a few examples of classes that implement the Map interface in Java. Each class has its own characteristics and is suitable for different use cases based on factors like concurrency, ordering requirements, and synchronization needs.


=================================
11- Few scenarios based question from Maps
=================================

Scenario: Adding and Retrieving Elements
Question: How do you add key-value pairs to a map, and how do you retrieve the value associated with a specific key?
Answer: To add a key-value pair, you can use the put(key, value) method. To retrieve the value associated with a specific key, you can use the get(key) method.

Scenario: Checking if a Key Exists
Question: How do you determine if a map contains a specific key?
Answer: You can use the containsKey(key) method to check if a map contains a specific key. It returns true if the key is present, and false otherwise.

Scenario: Updating a Value
Question: How do you update the value associated with a key in a map?
Answer: To update the value associated with a key, you can use the put(key, value) method again. If the key already exists, the new value will replace the existing one.

Scenario: Removing Elements
Question: How do you remove elements from a map, either by key or by a specific condition?
Answer: To remove an element by key, you can use the remove(key) method. If you want to remove elements based on a specific condition, you can iterate over the map's entries and remove them accordingly.

Scenario: Iterating Over Map Entries
Question: How do you iterate over the entries in a map and perform some operation on each entry?
Answer: You can use the entrySet() method to get a set of map entries, and then iterate over it using a loop or stream. Each entry contains a key-value pair that you can access and manipulate.

Scenario: Getting the Size of a Map
Question: How do you determine the number of key-value pairs in a map?
Answer: You can use the size() method to get the number of key-value pairs in a map. It returns an integer representing the size of the map.

Scenario: Clearing a Map
Question: How do you remove all elements from a map?
Answer: You can use the clear() method to remove all elements from a map. After calling this method, the map will be empty.

Scenario: Handling Default Values
Question: How do you handle cases where a key is not present in a map, and you want to return a default value instead?
Answer: You can use the getOrDefault(key, defaultValue) method to retrieve the value associated with a key. If the key is not present, it will return the default value provided.

Scenario: Sorting a Map
Question: How do you sort the entries of a map based on keys or values?
Answer: Maps in Java do not maintain the insertion order. To sort the entries based on keys or values, you can create a sorted map using the TreeMap class or use sorting techniques on the entries.

Scenario: Performing Bulk Operations
Question: How do you perform bulk operations, such as merging two maps or computing values based on keys?
Answer: To merge two maps, you can use the putAll(map) method to add all entries from one map into another. To compute values based on keys, you can use the compute(key, remappingFunction) method to perform custom computations on map values.

These scenarios and their answers cover various aspects of working with maps in Java. They can help assess your knowledge and understanding of map manipulation, retrieval, iteration, and other map-related operations.


=============================
12- OOPS concept in Java and ther usage
================================
Object-Oriented Programming (OOP) is a programming paradigm that focuses on creating objects, which are instances of classes, to represent real-world entities and interact with each other. Java is an object-oriented programming language, and it implements various OOP concepts. Here are some key OOP concepts in Java and their usage:

Classes and Objects:

Classes are the blueprint or template for creating objects. They define the properties and behavior of objects.
Objects are instances of classes that represent specific entities. They have state (attributes) and behavior (methods).
Usage: You create classes to model entities in your application and create objects from those classes to work with data and perform operations.
Encapsulation:

Encapsulation refers to the bundling of data (attributes) and methods within a class, hiding the internal implementation details.
It allows for data protection and access control, as access to the class members is restricted to defined methods.
Usage: Encapsulation helps in achieving data abstraction and enhances code maintainability and reusability.
Inheritance:

Inheritance allows one class (child/subclass) to inherit the properties and methods of another class (parent/superclass).
It enables code reuse and supports the concept of "is-a" relationship between classes.
Usage: Inheritance is used to create specialized classes (child classes) based on common characteristics and behavior defined in a base class (parent class).
Polymorphism:

Polymorphism refers to the ability of an object to take on multiple forms.
In Java, polymorphism is achieved through method overriding (runtime polymorphism) and method overloading (compile-time polymorphism).
Usage: Polymorphism allows you to write more flexible and extensible code by treating objects of different classes in a uniform way.
Abstraction:

Abstraction focuses on hiding unnecessary details and exposing only essential features to the outside world.
It involves creating abstract classes and interfaces that define the contract for derived classes to implement.
Usage: Abstraction allows you to create a high-level view of a system, providing a simplified interface for interaction and reducing complexity.
These OOP concepts provide a foundation for writing modular, reusable, and maintainable code in Java. They enable code organization, code reuse, and better manageability of complex systems. By utilizing these concepts effectively, you can build robust and scalable applications.


======================================================
13- What is difference between Error and Exception in java and how to handle them
======================================================

In Java, both Error and Exception are subclasses of the Throwable class, but they represent different types of exceptional conditions. Here are the differences between Error and Exception:

Error:

Error represents serious and unrecoverable problems that are typically caused by the system or the environment.
Examples of Error include OutOfMemoryError, StackOverflowError, and VirtualMachineError.
Error indicates severe issues that usually cannot be handled programmatically and are not meant to be caught or recovered from.
It is generally not recommended to catch or handle Error in the code because they are usually fatal and indicate an abnormal state of the system.
The JVM typically terminates the program when an Error occurs.
Exception:

Exception represents exceptional conditions that can be handled programmatically.
Exception is further divided into two subcategories: checked exceptions and unchecked exceptions.
Checked exceptions (e.g., IOException, SQLException) are exceptions that must be declared in the method's signature or caught in a try-catch block.
Unchecked exceptions (e.g., NullPointerException, ArrayIndexOutOfBoundsException) are exceptions that do not need to be declared or caught explicitly.
Exception allows for the possibility of handling and recovering from exceptional situations in the code.
To handle exceptions, you can use try-catch blocks to catch specific exceptions and handle them gracefully or let them propagate to higher levels of the code.
You can also use the throws keyword to declare checked exceptions in method signatures and handle them at a higher level.
To handle exceptions in Java, you can use the following approaches:

try-catch blocks: Surround the code that may throw an exception with a try block and catch the specific exception type(s) in the catch block to handle them appropriately.
finally block: Use a finally block to specify code that should be executed regardless of whether an exception occurs or not.
Propagating exceptions: If you are unable to handle an exception locally, you can let it propagate to higher levels by declaring it in the method signature using the throws keyword.
Exception handling best practices: Handle exceptions based on the specific situation, provide meaningful error messages, and log exceptions for debugging and troubleshooting purposes.
Remember that it's important to handle exceptions appropriately in your code to ensure proper error handling, graceful recovery, and to maintain the stability of your program.


=============
14- Super vs this
=============

super and this are both keywords in Java that are used to refer to different elements within a class hierarchy. Here's a comparison between super and this:

Usage:

super: It is used to refer to the superclass or parent class members (variables, methods, and constructors) from within a subclass. It is often used when the subclass overrides a method or hides a field of the superclass and needs to access the superclass version.
this: It is used to refer to the current instance of the class. It can be used to access instance variables, invoke instance methods, or invoke the current class's constructor.
Reference:

super: It references the superclass or parent class.
this: It references the current instance of the class.
Constructor invocation:

super: It is used to invoke the superclass constructor from a subclass constructor. This is done to initialize the inherited members of the subclass.
this: It is used to invoke another constructor within the same class. This is often used for constructor chaining, where one constructor calls another constructor to avoid code duplication.
Accessing members:

Super: It is used to access or call superclass members that are hidden or overridden by the subclass. It is useful when you want to differentiate between the superclass and subclass versions of a method or field.
this: It is used to access instance variables and invoke instance methods within the same class. It is useful when there is a need to disambiguate between instance variables and parameters or to invoke methods without explicit instance references.
Scope:

super: It can be used within a subclass to access superclass members.
this: It can be used within a class to refer to instance members of the same class.
In summary, super is used to refer to the superclass and access its members, while this is used to refer to the current instance of the class. Both keywords have distinct purposes and usage within a class hierarchy.



=====================
15- Examples of polymorphism
=====================
Polymorphism is one of the key features of object-oriented programming (OOP) that allows objects of different types to be treated as objects of a common superclass. Here are a few examples of polymorphism in Java:

Method Overloading:


public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
In the above example, the add method is overloaded with different parameter lists. We can call the same method name with different arguments, and the appropriate method will be executed based on the number and types of arguments provided.

Method Overriding:


public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}
In this example, the makeSound method is overridden in the Dog class, which is a subclass of Animal. When we call the makeSound method on a Dog object, it executes the overridden method in the Dog class, demonstrating polymorphic behavior.

Polymorphic References:


public class Shape {
    public void draw() {
        System.out.println("Drawing a shape");
    }
}

public class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

public class Square extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a square");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Square();

        shape1.draw(); // Output: "Drawing a circle"
        shape2.draw(); // Output: "Drawing a square"
    }
}
In this example, we have a Shape superclass and two subclasses Circle and Square. We create objects of the subclasses and assign them to a reference of the superclass Shape. This allows us to treat the objects polymorphically, and when we invoke the draw method, it calls the appropriate overridden method based on the actual type of the object.

These are just a few examples of polymorphism in Java, showcasing the flexibility and extensibility of object-oriented programming concepts.


==============================
16- Difference between abstract and interfaces
==============================

The main differences between abstract classes and interfaces in Java are as follows:

Definition:

Abstract Class: An abstract class is a class that can contain both regular and abstract methods. It is declared using the abstract keyword.
Interface: An interface is a collection of abstract methods. It is declared using the interface keyword.
Inheritance:

Abstract Class: A class can extend only one abstract class, as Java supports single inheritance.
Interface: A class can implement multiple interfaces, as Java supports multiple inheritance through interfaces.
Method Implementation:

Abstract Class: An abstract class can have both implemented methods (regular methods with a body) and abstract methods (methods without a body). Subclasses are required to implement or override abstract methods.
Interface: An interface can only have abstract methods. All methods declared in an interface are implicitly public and abstract. Classes implementing an interface are required to provide implementations for all the methods.
Constructor:

Abstract Class: An abstract class can have constructors, which are called when creating an instance of a concrete subclass.
Interface: An interface cannot have constructors. It is not possible to create an instance of an interface.
Access Modifiers:

Abstract Class: An abstract class can have a mix of access modifiers for its members, including private, protected, and public.
Interface: All members of an interface are implicitly public. Interfaces do not allow private or protected members.
Variables:

Abstract Class: An abstract class can have instance variables, static variables, and constants.
Interface: Interfaces can have only constant variables (static final variables).
Extensibility:

Abstract Class: An abstract class can be extended by a subclass, which allows for code reuse and extension of functionality.
Interface: Interfaces are used to define a contract that classes must adhere to. They are used for achieving multiple inheritance-like behavior and to define common behavior across unrelated classes.
In summary, abstract classes are used when there is a need for common functionality and state among related classes, while interfaces are used to define contracts and achieve multiple inheritance-like behavior. Abstract classes allow a mix of implemented and abstract methods, while interfaces only have abstract methods.


==========================
17- Types of access modfiers - examples
==========================

Access modifiers in Java control the visibility and accessibility of classes, methods, and variables. There are four types of access modifiers in Java:

Public: The public access modifier allows the class, method, or variable to be accessed from anywhere, i.e., from any package, class, or subclass.
Example:


public class MyClass {
    public void publicMethod() {
        // Code here
    }
}
In this example, the publicMethod() can be accessed by any other class or subclass.

Private: The private access modifier restricts the visibility of the class, method, or variable to within the same class only. It cannot be accessed from other classes or subclasses.
Example:


public class MyClass {
    private int privateVariable;

    private void privateMethod() {
        // Code here
    }
}
In this example, the privateVariable and privateMethod() can only be accessed within the same class.

Protected: The protected access modifier allows the class, method, or variable to be accessed within the same package, as well as by subclasses even if they are in different packages.
Example:


public class MyClass {
    protected int protectedVariable;

    protected void protectedMethod() {
        // Code here
    }
}
In this example, the protectedVariable and protectedMethod() can be accessed by classes in the same package and by subclasses in any package.

Default (Package-private): If no access modifier is specified, it is considered as the default access modifier. It allows the class, method, or variable to be accessed within the same package only.
Example:


class MyClass {
    int defaultVariable;

    void defaultMethod() {
        // Code here
    }
}
In this example, the defaultVariable and defaultMethod() can only be accessed within the same package.

Note: The access modifiers are hierarchical, meaning that public is the highest level of accessibility, followed by protected, default, and private, which is the most restricted.

It's important to choose the appropriate access modifier based on the desired visibility and encapsulation requirements of the class, method, or variable.


===================
18- Types of variables in java
===================

n Java, there are three types of variables:

Local Variables: Local variables are declared within a method, constructor, or block and are accessible only within that scope. They are not accessible from other methods or blocks within the class.
Example:


public class MyClass {
    public void myMethod() {
        int localVar = 10; // local variable
        System.out.println(localVar);
    }
}
In this example, localVar is a local variable declared within the myMethod() method.

Instance Variables: Instance variables are declared within a class but outside of any method, constructor, or block. They are associated with an instance of the class and each instance of the class has its own copy of instance variables. Instance variables can be accessed and modified within the class and its objects.
Example:


public class MyClass {
    int instanceVar; // instance variable

    public void setInstanceVar(int value) {
        instanceVar = value;
    }

    public int getInstanceVar() {
        return instanceVar;
    }
}
In this example, instanceVar is an instance variable that can be accessed and modified using setter and getter methods.

Static Variables (Class Variables): Static variables are declared using the static keyword and are associated with the class itself rather than with any instance of the class. They are shared by all instances of the class and can be accessed using the class name.
Example:


public class MyClass {
    static int staticVar; // static variable

    public static void setStaticVar(int value) {
        staticVar = value;
    }

    public static int getStaticVar() {
        return staticVar;
    }
}
In this example, staticVar is a static variable that can be accessed and modified using static methods.

It's important to understand the scope and lifetime of each type of variable and choose the appropriate type based on your programming requirements.


================
19- Static vs non static
================

Static and non-static are keywords used in Java to define the behavior and scope of variables, methods, and nested classes. Here are the differences between static and non-static elements in Java:

Scope:

Static: Static members belong to the class itself, and there is only one instance of them that is shared among all objects of the class. They can be accessed using the class name.
Non-static: Non-static members belong to individual objects of the class. Each object has its own copy of non-static members, and they can be accessed through object references.
Memory Allocation:

Static: Static members are allocated memory at the time of class loading, and they exist throughout the program's execution.
Non-static: Non-static members are allocated memory when objects are created, and they are destroyed when the objects are garbage-collected.
Accessibility:

Static: Static members can be accessed directly using the class name, without the need for object instantiation.
Non-static: Non-static members can only be accessed through object references.
Usage:

Static: Static members are commonly used for constants, utility methods, and shared data that need to be accessed by multiple objects.
Non-static: Non-static members are used for instance-specific data and behavior.
Initialization:

Static: Static variables and blocks are initialized only once, when the class is loaded. Static methods can be called without creating an instance of the class.
Non-static: Non-static variables and blocks are initialized every time an object is created. Non-static methods can only be called on instances of the class.
It's important to note that static members can access other static members directly, but they cannot access non-static members directly. Non-static members can access both static and non-static members directly.

By understanding the differences between static and non-static elements, you can effectively use them according to the requirements of your program and class design.


===================
20- Why main is static in java
===================

The main method in Java is declared as static because it serves as the entry point for the Java program. When you run a Java program, the Java Virtual Machine (JVM) starts executing the program by calling the main method.

Here are the reasons why the main method is declared as static:

Entry Point: The main method acts as the starting point of execution for a Java program. It needs to be accessible to the JVM without creating an instance of the class. By making it static, it can be invoked directly using the class name.

JVM Constraint: The JVM needs to invoke the main method before any objects are created from the class. Since static methods can be invoked without creating an instance of the class, the main method needs to be static to satisfy this requirement.

Simplicity: By making the main method static, it avoids the complexity of creating an object and invoking the method through an instance. It allows for a simple and straightforward entry point for the program.

Here's an example of the main method declaration:

java
Copy code
public class MyClass {
    public static void main(String[] args) {
        // Program execution starts here
        // ...
    }
}
In the above example, the main method is declared as public static void, which follows the standard signature for the main method in Java. The String[] args parameter allows command-line arguments to be passed to the program if needed.



==============================
21- why overriding is not possible with static
==============================

Overriding is not possible with static methods in Java because static methods belong to the class itself, not to individual instances of the class.

In Java, method overriding is a concept where a subclass provides its own implementation of a method that is already defined in its superclass. The subclass method must have the same signature (name, return type, and parameter types) as the superclass method.

However, static methods are associated with the class itself, and they are resolved at compile-time based on the reference type, not the runtime type of the object. Therefore, the concept of polymorphism, which is essential for method overriding, does not apply to static methods.

When you define a static method with the same signature in a subclass as a static method in its superclass, it is not considered overriding but rather method hiding. The subclass method simply hides the superclass method, and the method to be invoked is determined based on the reference type of the variable.

Here's an example to illustrate this behavior:


class Superclass {
    public static void staticMethod() {
        System.out.println("Superclass static method");
    }
}

class Subclass extends Superclass {
    public static void staticMethod() {
        System.out.println("Subclass static method");
    }
}

public class Main {
    public static void main(String[] args) {
        Superclass obj1 = new Superclass();
        Superclass obj2 = new Subclass();

        obj1.staticMethod(); // Output: "Superclass static method"
        obj2.staticMethod(); // Output: "Superclass static method"
    }
}
In the above example, although the staticMethod() is defined in both the Superclass and Subclass, when calling the method using the superclass reference obj2, the static method of the superclass is invoked. This is because the method resolution is based on the reference type, not the actual type of the object.

==========================
22- Can static method be overloaded
==========================
Yes, static methods can be overloaded in Java.

Method overloading is the practice of having multiple methods with the same name but different parameters in the same class. When you overload a method, you provide multiple versions of the method with different parameter lists.

Static methods are class-level methods that belong to the class itself rather than an instance of the class. They can be accessed using the class name directly, without creating an object of the class.

Since overloaded methods are differentiated by their parameter lists, you can have multiple static methods with the same name but different parameters. The compiler determines which method to invoke based on the arguments provided at the call site.

Here's an example of overloading a static method:


public class Example {
    public static void printMessage(String message) {
        System.out.println("Message: " + message);
    }

    public static void printMessage(int number) {
        System.out.println("Number: " + number);
    }

    public static void main(String[] args) {
        printMessage("Hello"); // Invokes the first overloaded method
        printMessage(42);      // Invokes the second overloaded method
    }
}
In the above example, the printMessage method is overloaded with two versions—one that accepts a String parameter and another that accepts an int parameter. Depending on the argument provided, the appropriate overloaded method is called.



====================
23- Can abstract class be final
=====================

No, an abstract class cannot be declared as final.

The final keyword is used to indicate that a class, method, or variable cannot be extended, overridden, or modified, respectively. However, an abstract class is designed to be extended by subclasses, so declaring it as final would contradict its purpose.

By marking a class as abstract, you are indicating that it is intended to serve as a base class for other classes to extend and implement its abstract methods. Subclasses can provide concrete implementations for the abstract methods and inherit the non-abstract methods and fields from the abstract class.

Therefore, you cannot combine the abstract and final keywords together when declaring a class. They represent conflicting concepts in Java's object-oriented programming model.


====================================
24- what are methods there to iterate over SET and MAP
====================================

In Java, there are several methods available to iterate over Set and Map collections. Here are the commonly used methods for iteration:

1. Iterating over a Set:

   ```java
   Set<String> set = new HashSet<>();
   
   // Method 1: Using an enhanced for loop
   for (String element : set) {
       // Process each element
   }

   // Method 2: Using an iterator
   Iterator<String> iterator = set.iterator();
   while (iterator.hasNext()) {
       String element = iterator.next();
       // Process each element
   }

   // Method 3: Using forEach() method with lambda expression (Java 8+)
   set.forEach(element -> {
       // Process each element
   });
   ```

2. Iterating over a Map:

   ```java
   Map<String, Integer> map = new HashMap<>();
   
   // Method 1: Iterating over keys and getting values
   for (String key : map.keySet()) {
       Integer value = map.get(key);
       // Process each key-value pair
   }

   // Method 2: Using an entrySet() and enhanced for loop
   for (Map.Entry<String, Integer> entry : map.entrySet()) {
       String key = entry.getKey();
       Integer value = entry.getValue();
       // Process each key-value pair
   }

   // Method 3: Using an iterator on entrySet()
   Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
   while (iterator.hasNext()) {
       Map.Entry<String, Integer> entry = iterator.next();
       String key = entry.getKey();
       Integer value = entry.getValue();
       // Process each key-value pair
   }

   // Method 4: Using forEach() method with lambda expression (Java 8+)
   map.forEach((key, value) -> {
       // Process each key-value pair
   });
   ```

These methods allow you to iterate over the elements of a Set or the key-value pairs of a Map and perform operations on each element or pair. Choose the appropriate method based on your requirements and the version of Java you are using.

========================
25- types of construtors in java
========================

In Java, there are several types of constructors that can be defined in a class. Constructors are special methods that are used to initialize objects when they are created. Here are the different types of constructors in Java:

1. Default Constructor: A default constructor is provided by the Java compiler if no constructor is explicitly defined in the class. It has no arguments and initializes the object with default values (null for object references, 0 for numeric types, etc.).

2. Parameterized Constructor: A parameterized constructor is a constructor that takes one or more parameters. It allows you to initialize the object with specific values provided during object creation. This type of constructor enables you to customize the initialization of objects.

3. Copy Constructor: A copy constructor is used to create a new object by copying the values from an existing object of the same class. It provides a way to create a deep copy of an object, ensuring that the new object has its own separate copy of all instance variables.

4. Constructor Overloading: Constructor overloading is a technique where multiple constructors are defined in a class with different parameter lists. Each constructor can have a unique set of parameters, allowing objects to be created with different initialization options.

5. Private Constructor: A private constructor is a constructor that is explicitly defined as private. It is typically used in utility classes or classes that should not be instantiated. A private constructor prevents the class from being instantiated outside of the class itself.

6. Protected Constructor: A protected constructor is a constructor that is accessible only within the same package or by subclasses. It restricts the visibility of the constructor to provide a level of encapsulation and control over object creation.

These are the common types of constructors in Java. Constructors play a crucial role in initializing objects and setting their initial state. By defining constructors with different parameter lists and access modifiers, you can control the object creation process and customize how objects are initialized.


==================================
26- java collection- difference between LIST and SET
==================================
Java Collections provide a framework for storing and manipulating groups of objects. The two commonly used interfaces in the Collection framework are List and Set. Here are the differences between List and Set in Java:

1. Definition:
   - List: List is an ordered collection that allows duplicate elements. It maintains the insertion order of elements, meaning the elements are stored in the same order as they are added.
   - Set: Set is an unordered collection that does not allow duplicate elements. It does not maintain any specific order of elements.

2. Duplicate Elements:
   - List: List allows duplicate elements, which means you can add the same object multiple times to a List.
   - Set: Set does not allow duplicate elements. If you try to add a duplicate element to a Set, it will not be added, and the Set remains unchanged.

3. Ordering:
   - List: List maintains the order of elements as they are added. You can access elements by their index using methods like `get(index)`.
   - Set: Set does not guarantee any specific order of elements. The elements are generally unordered, and you cannot access them by index.

4. Implementation:
   - List: List implementations in Java include ArrayList, LinkedList, and Vector. Each implementation has its characteristics and performance trade-offs.
   - Set: Set implementations in Java include HashSet, TreeSet, and LinkedHashSet. HashSet provides constant-time performance for basic operations, TreeSet maintains elements in sorted order, and LinkedHashSet maintains the order of elements as they are added.

5. Usage:
   - List: Lists are commonly used when the order of elements matters, and duplicates need to be preserved. They are suitable for scenarios where you need to access elements by their index, perform positional operations (such as adding, removing, or accessing elements at specific positions), or allow duplicates.
   - Set: Sets are used when you need to maintain a collection of unique elements. They are useful for scenarios where you want to ensure uniqueness and don't require a specific order of elements.

6. Performance:
   - List: The performance of List operations depends on the implementation. ArrayList provides efficient random access but may be slower for inserting or removing elements in the middle. LinkedList is efficient for insertions and removals but slower for random access.
   - Set: The performance of Set operations also depends on the implementation. HashSet offers constant-time performance for basic operations but does not maintain any order. TreeSet provides log-time performance for basic operations and maintains the elements in sorted order. LinkedHashSet provides predictable iteration order and performs slightly slower than HashSet.

It's important to choose the appropriate collection based on your specific requirements. If you need an ordered collection that allows duplicates and provides positional access, List is the better choice. If you require a collection of unique elements without any specific order, Set is the suitable option.


==========================================================
27- Difference between StringBuilder and StringBuffer - synchonization and thread safety
==========================================================
Both `StringBuilder` and `StringBuffer` are classes in Java that provide mutable sequences of characters. However, there are some differences between them:

1. Mutability:
   - `StringBuilder`: `StringBuilder` is mutable, meaning the contents of the sequence can be modified. It is not thread-safe.
   - `StringBuffer`: `StringBuffer` is also mutable like `StringBuilder` but with an added feature of being thread-safe. It ensures that multiple threads can safely access and modify the sequence without any interference.

2. Thread Safety:
   - `StringBuilder`: `StringBuilder` is not inherently thread-safe. If multiple threads access and modify a `StringBuilder` object simultaneously, it can lead to unpredictable behavior or data corruption.
   - `StringBuffer`: `StringBuffer` is designed to be thread-safe. It provides synchronized methods, allowing multiple threads to safely access and modify a `StringBuffer` object without conflicts.

3. Performance:
   - `StringBuilder`: `StringBuilder` is generally more efficient in terms of performance because it is not synchronized. However, it sacrifices thread-safety for better performance.
   - `StringBuffer`: `StringBuffer` is slightly slower in performance due to the overhead of synchronization. It ensures thread-safety by synchronizing access to the methods, which can impact performance in a multi-threaded environment.

4. Usage:
   - `StringBuilder`: `StringBuilder` is commonly used in situations where thread-safety is not a concern, such as single-threaded environments or scenarios where you can ensure exclusive access to the object.
   - `StringBuffer`: `StringBuffer` is preferred when thread-safety is required, such as in multi-threaded applications or when multiple threads need to access and modify a string buffer concurrently.

5. Availability:
   - `StringBuilder` and `StringBuffer` are both available since Java 1.0 and provide similar functionality. However, `StringBuilder` was introduced in Java 1.5 as a non-synchronized alternative to `StringBuffer` for improved performance.

In general, if you are working in a single-threaded environment or can handle synchronization manually, `StringBuilder` is recommended due to its better performance. If thread-safety is a concern or multiple threads need to access and modify the sequence concurrently, `StringBuffer` is the appropriate choice.


==================================================
28- how many objectes will get created for local, instance and static variables
===================================================

The number of objects created for local, instance, and static variables depends on the specific context and usage within a Java program. Here's an explanation of how objects are created for each type of variable:

1. Local Variables:
   - Local variables are declared and used within a method, constructor, or block.
   - Each time the method, constructor, or block is executed, a new set of local variables is created.
   - Objects are created explicitly using the `new` keyword or implicitly when a method or constructor returns an object.
   - The objects created within the method or block are eligible for garbage collection once the method or block completes execution.
   - The number of objects created for local variables depends on how many times the method, constructor, or block is executed.

2. Instance Variables:
   - Instance variables are declared within a class but outside of any method, constructor, or block.
   - Each instance of the class (i.e., each object) has its own copy of instance variables.
   - Objects are created explicitly using the `new` keyword when an instance of the class is instantiated.
   - The number of objects created for instance variables depends on how many instances of the class are created.

3. Static Variables:
   - Static variables are declared with the `static` keyword and are shared among all instances of a class.
   - Static variables are associated with the class itself, rather than with individual objects.
   - Objects are created explicitly using the `new` keyword when an instance of the class is instantiated.
   - The number of objects created for static variables depends on how many instances of the class are created.

To summarize:
- Local variables create new objects each time a method, constructor, or block is executed.
- Instance variables create separate objects for each instance of the class.
- Static variables are not directly associated with objects but are shared among all instances of the class.

The actual number of objects created for local, instance, and static variables will vary depending on the specific program logic and execution flow.

=========================================================================
Certainly! Here's a tabular representation of the number of objects created for local, instance, and static variables:

| Variable Type   | Number of Objects Created                                   |
|-----------------|-----------------------------------------------------------|
| Local Variables | Multiple instances can be created, depending on execution flow and method/block invocations. Each method/block execution creates a new set of local variables. |
| Instance Variables | One instance per object created. Each instance of the class has its own copy of instance variables. |
| Static Variables | One instance shared across all instances of the class. Static variables are not directly associated with objects but with the class itself. |

It's important to note that the number of objects created for local variables depends on how many times the method or block is executed. For instance variables, the number of objects created depends on the number of instances of the class created. Static variables, on the other hand, are not directly associated with object instances but are shared among all instances of the class.

Keep in mind that this table provides a general overview, and the actual number of objects created can vary based on the specific implementation and usage in a Java program.

=============
29- maven profiles
=============

Apache Maven goes to great lengths to ensure that builds are portable. Among other things, this means allowing build configuration inside the POM, avoiding all filesystem references (in inheritance, dependencies, and other places), and leaning much more heavily on the local repository to store the metadata needed to make this possible.

However, sometimes portability is not entirely possible. Under certain conditions, plugins may need to be configured with local filesystem paths. Under other circumstances, a slightly different dependency set will be required, and the project's artifact name may need to be adjusted slightly. And at still other times, you may even need to include a whole plugin in the build lifecycle depending on the detected build environment.

To address these circumstances, Maven supports build profiles. Profiles are specified using a subset of the elements available in the POM itself (plus one extra section), and are triggered in any of a variety of ways. They modify the POM at build time, and are meant to be used in complementary sets to give equivalent-but-different parameters for a set of target environments (providing, for example, the path of the appserver root in the development, testing, and production environments). As such, profiles can easily lead to differing build results from different members of your team. However, used properly, profiles can be used while still preserving project portability. This will also minimize the use of -f option of maven which allows user to create another POM with different parameters or configuration to build which makes it more maintainable since it is running with one POM only.


=============
30- Throwable 
=============

In Java, `Throwable` is the root class of all exceptions and errors. It serves as the base class for the exception handling hierarchy. The `Throwable` class itself can be divided into two main subclasses: `Exception` and `Error`.

1. Exception: Exceptions represent exceptional conditions that can be caught and handled by the program. They are further divided into two categories:

   a. Checked Exceptions: These are the exceptions that must be declared in the method signature or caught using try-catch blocks. They are checked by the compiler during compilation to ensure that they are properly handled. Examples include `IOException`, `SQLException`, and `ClassNotFoundException`.

   b. Unchecked Exceptions (Runtime Exceptions): These exceptions do not need to be declared or caught explicitly. They are often caused by programming errors or logical errors in the code. Examples include `NullPointerException`, `ArrayIndexOutOfBoundsException`, and `ArithmeticException`.

2. Error: Errors represent serious problems that generally cannot be recovered from. They are typically caused by external factors or failures in the Java Virtual Machine (JVM). Errors are not meant to be caught and handled by the application code. Examples include `OutOfMemoryError`, `StackOverflowError`, and `NoClassDefFoundError`.

Both `Exception` and `Error` classes inherit from the `Throwable` class, which provides common methods and properties for handling exceptions and errors. These methods include `getMessage()` to retrieve the error message, `printStackTrace()` to print the stack trace of the exception or error, and others for handling and propagating exceptions.

In addition to `Exception` and `Error`, there are also subtypes and subclasses that extend the `Exception` class, such as `RuntimeException`, `IOException`, `SQLException`, and many more. These subclasses provide specific categories of exceptions for different types of errors or exceptional conditions that may occur during program execution.

By understanding the hierarchy of `Throwable` and its subclasses, developers can effectively handle exceptions and errors in their Java programs, providing appropriate error handling and graceful error recovery mechanisms.


=======================
31- try with resoures in exception
======================

In Java, the "try-with-resources" statement is used to automatically manage resources that implement the `AutoCloseable` interface. It ensures that the resources are properly closed regardless of whether an exception occurs or not. The `try-with-resources` statement simplifies the code for handling resources and ensures that they are released correctly.

Here's the basic syntax of the try-with-resources statement:

```java
try (ResourceType resource1 = new ResourceType(); ResourceType resource2 = new ResourceType()) {
    // Code that uses the resources
} catch (ExceptionType exception) {
    // Exception handling code
}
```

In this syntax:

1. `ResourceType` represents the type of resource that implements the `AutoCloseable` interface, such as `FileInputStream`, `BufferedReader`, or any custom class that implements `AutoCloseable`.

2. The resources are declared and initialized within the parentheses after the `try` keyword. You can declare and initialize multiple resources by separating them with semicolons.

3. The code block inside the `try` block is where you use the resources.

4. After the execution of the `try` block, the resources are automatically closed, regardless of whether an exception occurs or not.

5. If an exception is thrown within the `try` block, the catch block (if provided) will handle the exception.

The try-with-resources statement guarantees that the `close()` method of each resource is called in reverse order of their creation. This ensures that resources are released properly, even if an exception is thrown.

Here's an example that demonstrates the usage of try-with-resources with a `BufferedReader`:

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Example {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            // Exception handling
            e.printStackTrace();
        }
    }
}
```

In this example, the `BufferedReader` resource is created within the try-with-resources statement. The `readLine()` method is used to read lines from the file. When the code exits the `try` block, the `BufferedReader` is automatically closed, regardless of whether an exception occurs or not.

The try-with-resources statement helps in writing cleaner and more robust code by handling resource management automatically, reducing the chance of resource leaks and ensuring proper cleanup.


==========================================================
32- what is scope in pom.xml - used to define the visibility and availability of dependencies
==========================================================
In a `pom.xml` file, the `<scope>` element is used to define the visibility and availability of dependencies declared within the project. It specifies how the dependency is used at various stages of the build process.

The `<scope>` element can take one of the following values:

1. `compile` (default): This is the default scope. Dependencies with this scope are available during the entire build process (compilation, testing, and runtime). They are also included in the final artifact (e.g., JAR) that is produced by the project.

2. `provided`: Dependencies with this scope are required for compiling and testing the project but are expected to be provided by the runtime environment. For example, Java EE APIs such as servlet and JSP APIs are typically marked as `provided` because they are provided by the application server or container.

3. `runtime`: Dependencies with this scope are not needed for compilation but are required during runtime. They are not included in the final artifact produced by the project. An example is a JDBC driver that is needed to connect to a database at runtime.

4. `test`: Dependencies with this scope are only used for testing the project and are not included in the final artifact. They are available during the test compilation and test execution phases.

5. `system`: Dependencies with this scope are similar to `provided` dependencies but require an explicit system path to be specified. This scope should be used sparingly as it bypasses the normal dependency mechanism and can lead to build portability issues.

6. `import`: This scope is used only in dependency management sections. It allows you to import dependencies that are specified in another POM file. The imported dependencies are not used during the build, but they allow you to manage common dependencies in a centralized manner.

Specifying the appropriate scope for dependencies is important as it helps manage the build process efficiently and ensures that only the required dependencies are included in the final artifact. It also helps in maintaining the desired separation of concerns and avoids unnecessary bloating of the artifact with unnecessary dependencies.

=========================

=========================
Abstract class:

An abstract class is a class that cannot be instantiated. It serves as a blueprint for its subclasses.
It may contain both abstract and non-abstract methods.
It can have constructors, instance variables, and static variables.
It can have instance methods and static methods.
It can also have final methods, which cannot be overridden by subclasses.
It may or may not have abstract methods.
Abstract classes can provide default implementations for methods, which subclasses can inherit or override.

Abstract method:

An abstract method is a method declared without an implementation.
It does not have a body; it ends with a semicolon instead of curly braces.
It is declared using the abstract keyword in the method signature.
It must be defined in an abstract class or an interface.
Subclasses of an abstract class must provide an implementation for all abstract methods, or they must be declared abstract themselves.
Abstract methods define a contract that subclasses must follow by providing their own implementation.
They allow for polymorphism, as different subclasses can provide different implementations for the same abstract method.
These features of abstract classes and methods in Java enable abstraction, modularity, and provide a way to define common behavior that subclasses can inherit or override based on their specific needs.

=======================
33- Can we declare a private class?
=======================
Yes, it is possible to declare a private class in Java. A private class is a nested class that is defined within another class and has restricted visibility. Here are a few key points to consider:

1. Scope: A private class can only be accessed within the enclosing class that it is defined in. It is not visible outside of that class, including other classes in the same package or subclasses.

2. Nested Class Types: There are different types of nested classes in Java, including inner classes, static nested classes, local classes, and anonymous classes. All of these types can be declared as private, restricting their visibility.

3. Enclosing Class Relationship: A private class has direct access to the members (fields, methods, constructors) of the enclosing class, including private members. This allows for tighter encapsulation and information hiding within the scope of the enclosing class.

4. Usage and Scenarios: Private classes are often used to encapsulate implementation details or provide internal utility classes that are only relevant to the enclosing class. They can help in organizing and structuring code within a class and prevent access from other classes, enhancing encapsulation and modularity.

Here's an example illustrating the declaration of a private class:

```java
public class OuterClass {
    private class PrivateInnerClass {
        // Private class implementation
    }

    public void doSomething() {
        PrivateInnerClass inner = new PrivateInnerClass();
        // Access private class and its members within the enclosing class
    }
}
```

In this example, the class `PrivateInnerClass` is declared as private within the `OuterClass`. It can only be accessed within the `OuterClass` itself, allowing for encapsulation and restricting visibility outside of the enclosing class.

Note that private classes should be used judiciously and only when necessary to maintain proper encapsulation and information hiding. In many cases, alternative approaches such as private methods or local variables may be more suitable for achieving the desired functionality.



==================================
34- What is the difference between == and equals?
==================================

==================================
35. How is the string immutable?
==================================

==================================
36. Where strings get stored and where does the reference get stored?
==================================

==================================
37. Can you please explain with reference the memory location of how the string is immutable?
==================================

==================================
38. If you don't want to use the String class then what can be used?
==================================

==================================
39. Difference between String and StringBuffer.
==================================

==================================
40. What collections have you used?
==================================

==================================
41. Have you used HashMap?
==================================

==================================
42. List declaration?
==================================

==================================
43. Where is the Set used?
==================================

==================================
45. I have a table and want to store all table data Then which collection should be used and why?
==================================

==================================
46. What HashMap will return?
==================================

==================================
47. How to achieve inheritance without having an interface?
==================================

==================================
48. Method overloading and method overriding? Where used in the framework?
==================================

==================================
49. If I want that my class should not be extended and the instance cannot be created by other classes then how to declare class?
==================================

==================================
50. How to store multiple values in one reference?
==================================

==================================
51- Difference between Throw and Throws.
==================================

==================================
52. If an exception is declared in throws and if an exception is encountered what will happen?
==================================

==================================
53. Difference between try/catch block and throws.
==================================

==================================
54- Difference between Class and Instance variables.
==================================

==================================
55- How does hashmap work?
==================================
HashMap is an implementation of the Map interface in Java that provides key-value pair storage and retrieval functionality. It uses a technique called hashing to store and retrieve elements efficiently. Here's a high-level overview of how HashMap works:

1. Hashing:
   - When you insert a key-value pair into a HashMap, the key's `hashCode()` method is called to generate a hash code. The hash code is an integer value that represents the key.
   - The hash code is further processed using a hashing algorithm (such as the default `hash()` function in Java) to calculate an index within the underlying array where the key-value pair will be stored.

2. Bucket and Linked List:
   - HashMap uses an array of "buckets" to store key-value pairs. Each bucket represents a specific index in the array.
   - In case of hash collisions (when two or more keys produce the same hash code), a linked list is used to store multiple entries in the same bucket. Each entry contains a key-value pair.

3. Storing Key-Value Pairs:
   - After calculating the index based on the hash code, HashMap stores the key-value pair in the corresponding bucket.
   - If the bucket is empty, the key-value pair is stored directly. If there is already an entry in the bucket, it is added to the linked list as a new node.

4. Retrieving Values:
   - To retrieve a value associated with a key, the key's `hashCode()` method is called again to calculate the index.
   - HashMap searches the bucket at that index for the desired key. If the bucket is empty or there is no matching key, it means the key is not present in the HashMap.
   - If a match is found, HashMap uses the key's `equals()` method to verify the exact match and retrieves the corresponding value.

5. Resizing and Rehashing:
   - HashMap automatically adjusts its internal capacity to maintain a balance between space and performance. It has a load factor (default value 0.75) that determines the threshold for resizing.
   - When the number of elements exceeds the load factor times the current capacity, the array is resized, and all the key-value pairs are rehashed and redistributed across the new array.

6. Performance:
   - HashMap provides constant-time performance (O(1)) for basic operations like `get()`, `put()`, and `remove()` on average.
   - However, in the case of hash collisions, the performance may degrade to O(n) if all keys hash to the same index, causing the linked list to become too long.
   - By adjusting the initial capacity and load factor appropriately, you can balance the trade-off between memory usage and performance.

HashMap provides efficient storage and retrieval of key-value pairs by using the hashing technique and maintaining buckets with linked lists. It offers a flexible and convenient way to work with associative arrays and lookup tables in Java.



